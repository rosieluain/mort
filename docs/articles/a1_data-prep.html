<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Formatting your data</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Formatting your data</h1>



<p>All mort functions rely on residence events. Residence events are
similar to detection data, but include a start time, an end time, and
duration. Before proceeding to explore your data and flag potential
mortalities in mort, detection data must be converted into residence
events. This can be done within mort using the <code>residences()</code>
function, functions from other packages for acoustic telemetry data, or
manually.</p>
<div id="mort-format" class="section level2">
<h2>mort format</h2>
<p>Residence events are generated in morts from detection data, using
the <code>residences()</code> function.</p>
<p>Detection data can be in any format and have any number of columns,
provided they have a datetime column, a location column, and an animal
ID column:</p>
<table>
<thead>
<tr class="header">
<th align="center">DateTimeUTC</th>
<th align="center">Station.Name</th>
<th align="center">ID</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">2003-09-21 23:49:45</td>
<td align="center">11</td>
<td align="center">A</td>
</tr>
<tr class="even">
<td align="center">2003-09-21 23:51:29</td>
<td align="center">11</td>
<td align="center">A</td>
</tr>
<tr class="odd">
<td align="center">2003-09-21 23:57:45</td>
<td align="center">11</td>
<td align="center">A</td>
</tr>
<tr class="even">
<td align="center">2003-09-21 23:59:08</td>
<td align="center">11</td>
<td align="center">A</td>
</tr>
<tr class="odd">
<td align="center">2003-09-22 00:08:18</td>
<td align="center">11</td>
<td align="center">A</td>
</tr>
<tr class="even">
<td align="center">2003-09-22 00:20:28</td>
<td align="center">1</td>
<td align="center">A</td>
</tr>
</tbody>
</table>
<p>A residence event either ends when the animal is detected at a new
station or when the animal has not been detected longer than a
user-defined cutoff (defined with the arguments <code>cutoff</code> and
<code>units</code>):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>res.events<span class="ot">&lt;-</span><span class="fu">residences</span>(<span class="at">data=</span>detections,<span class="at">ID=</span><span class="st">&quot;ID&quot;</span>,<span class="at">station=</span><span class="st">&quot;Station.Name&quot;</span>,<span class="at">datetime=</span><span class="st">&quot;DateTimeUTC&quot;</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">cutoff=</span><span class="dv">1</span>,<span class="at">units=</span><span class="st">&quot;days&quot;</span>)</span></code></pre></div>
<table>
<colgroup>
<col width="25%" />
<col width="17%" />
<col width="4%" />
<col width="25%" />
<col width="26%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">ResidenceStart</th>
<th align="center">Station.Name</th>
<th align="center">ID</th>
<th align="center">ResidenceEnd</th>
<th align="center">ResidenceLength.days</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">2003-09-21 23:49:45</td>
<td align="center">11</td>
<td align="center">A</td>
<td align="center">2003-09-22 00:08:18</td>
<td align="center">0.0128819</td>
</tr>
<tr class="even">
<td align="center">2003-09-22 00:20:28</td>
<td align="center">1</td>
<td align="center">A</td>
<td align="center">2003-09-22 00:50:36</td>
<td align="center">0.0209259</td>
</tr>
<tr class="odd">
<td align="center">2003-09-24 16:56:36</td>
<td align="center">1</td>
<td align="center">A</td>
<td align="center">2003-10-11 17:15:47</td>
<td align="center">17.0133218</td>
</tr>
<tr class="even">
<td align="center">2003-10-25 14:27:06</td>
<td align="center">1</td>
<td align="center">A</td>
<td align="center">2003-10-25 14:59:47</td>
<td align="center">0.0226968</td>
</tr>
<tr class="odd">
<td align="center">2003-10-26 16:11:13</td>
<td align="center">1</td>
<td align="center">A</td>
<td align="center">2003-10-26 17:42:09</td>
<td align="center">0.0631481</td>
</tr>
<tr class="even">
<td align="center">2004-06-23 22:42:20</td>
<td align="center">1</td>
<td align="center">A</td>
<td align="center">2004-06-24 01:15:25</td>
<td align="center">0.1063079</td>
</tr>
</tbody>
</table>
<p><code>ID</code> is defined by the user. ID could be the tag
transmitter ID, the tag serial number, or a unique ID associated with
the detections by the user. If the latter, <code>residences()</code> and
the other functions in mort can accommodate multiple tag deployments
(i.e., a tag is returned and re-deployed on another animal), because the
ID is unique to the animal.</p>
<p><code>station</code> is also defined by the user. It could be the
receiver serial number (if the same receiver is always deployed at the
same location), a unique location name, or a cluster of receivers
(similar to Array in the <a href="https://CRAN.R-project.org/package=actel">actel</a> package).</p>
<p>Note that <code>units</code> specifies the units of the cutoff (in
the example above, the cutoff is 1 day). These units will also be used
to calculate the residence duration.</p>
<p>Dates and times must be of class POSIXt, or must be in the format
“YYYY-mm-dd HH:MM:SS”. Note that mort assumes that dates are in UTC. If
your datetimes are in POSIXt, mort will convert them to UTC. If your
dates are in local time, it is recommended that you convert your
datetime column to class POSIXt and that you change the time zone to
UTC:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>data<span class="sc">$</span>DateTimeUTC<span class="ot">&lt;-</span><span class="fu">as.POSIXct</span>(data<span class="sc">$</span>DateTimeLocal,<span class="at">format=</span><span class="st">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>                             <span class="at">tz=</span><span class="st">&quot;America/Edmonton&quot;</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">attributes</span>(data<span class="sc">$</span>DateTimeUTC)<span class="sc">$</span>tzone<span class="ot">&lt;-</span><span class="st">&quot;UTC&quot;</span></span></code></pre></div>
</div>
<div id="other-formats" class="section level2">
<h2>Other formats</h2>
<p>mort functions support the output from other packages for acoustic
telemetry data. Note that the following information will be most useful
if referenced while exploring the other mort functions.</p>
<div id="actel" class="section level3">
<h3>actel</h3>
<p>Residence events are called “movement events” in <a href="https://CRAN.R-project.org/package=actel">actel</a>, and are
generated using the <code>explore()</code> function.</p>
<p>Actel provides residence duration in the format HH:MM:SS. mort
converts the duration to a numeric vector, with units of seconds.</p>
<p>Dates in actel are in local time and will be converted to UTC by
mort. Users will receive a warning when this happens, including a
reminder to verify that the time zone in the actel output is
correct.</p>
<pre><code>#&gt; Warning: If actel date/times are in local time, they will be converted to UTC.
#&gt; Verify that time zone in actel output is correct.</code></pre>
</div>
<div id="glatos" class="section level3">
<h3>glatos</h3>
<p>Residence events are called “detection events” in <a href="https://github.com/ocean-tracking-network/glatos">glatos</a>, and
are generated using the <code>detection_events()</code> function.</p>
<p>glatos uses seconds for the units of residence duration and UTC as
the timezone for datetimes.</p>
</div>
<div id="vtrack" class="section level3">
<h3>VTrack</h3>
<p>Residence events are called “residences” in <a href="https://github.com/RossDwyer/VTrack">VTrack</a>, and are generated
using the <code>RunResidenceExtraction()</code> function.</p>
<p>As of VTrack version 2.10, it looks as though VTrack assigns the
local time of the user’s computer to datetimes. As detection data are
typically downloaded in UTC, mort assumes that the datetimes output by
VTrack are actually in UTC, rather than local time. Users will receive a
warning when using VTrack residence events:</p>
<pre><code>#&gt; Warning: Assuming that VTrack date/times are in UTC. If they are in local
#&gt;             time, please convert to UTC before running</code></pre>
<p>Also as of VTrack version 2.10, VTrack calculates the duration of
residence events from single detections differently, depending on
whether the end of the residence event was due to a station change or
the gap in detections exceeded the time threshold. mort recalculates the
duration of VTrack residence events, with units of seconds. Users will
receive a warning as a reminder that the duration in mort outputs may
not match the duration in VTrack:</p>
<pre><code>#&gt; Warning: When the duration of an event is 0 s (a single detection) and
#&gt;             the reason for ending the event (ENDREASON) is &#39;timeout&#39;, Vtrack
#&gt;             gives DURATION as the time between the current event and the next, not
#&gt;             the duration of the current event. DURATION was recalculated as
#&gt;             the duration of the events themselves, to better align with other
#&gt;             packages.</code></pre>
</div>
<div id="other-packages" class="section level3">
<h3>Other packages?</h3>
<p>If we have missed any other packages that generate residence events,
please let us know and start a new issue. We will work to incorporate
other formats if feasible. To support other formats in mort, the
residence events must have, at minimum, four columns: animal ID,
station/location name, residence start time, and residence end time. The
column names can vary from those used in mort, but must be consistent
within the generating package. If the residence events include duration,
the units must either be specified or invariant.</p>
</div>
</div>
<div id="manual-formatting" class="section level2">
<h2>Manual formatting</h2>
<p>All mort functions will accept manual formatting (using the argument
<code>type=&quot;manual&quot;</code>). Manual formatting must be used if you have
your own method for generating residence events. Manual formatting must
also be used if you have used <code>residences()</code> or a function
from another supported package to generate residence events, and then
either modified the format (e.g., converted an actel list to a
dataframe) or renamed the columns.</p>
<p>There are five mandatory columns for manually formatted data:</p>
<ol>
<li>Animal ID - either character or numeric</li>
<li>Station/location - either character or numeric</li>
<li>Residence start - must be POSIXt or a character in the format
“YYYY-mm-dd HH:MM:SS”. mort assumes that all dates and times are UTC. If
your data are in a local time zone, residence start should be in class
POSIXt and the time zone should be specified.</li>
<li>Residence end - must be formatted as for residence start</li>
<li>Residence duration - the difference in time between residence end
and residence start. May be either numeric or difftime class. The units
of residence duration must also be known and specified for many mort
functions.</li>
</ol>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
